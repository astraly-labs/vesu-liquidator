use std::{sync::Arc, time::Duration};

use anyhow::{anyhow, Result};
use bigdecimal::BigDecimal;
use lazy_static::lazy_static;
use starknet::{
    accounts::Call,
    core::types::{Felt, TransactionFinalityStatus},
    providers::{jsonrpc::HttpTransport, JsonRpcClient, Provider},
};
use tokio::sync::mpsc::Receiver;
use tokio::time::interval;

use crate::{
    oracle::PragmaOracle,
    types::account::StarknetAccount,
    types::position::{Position, PositionsMap},
};

lazy_static! {
    pub static ref MINIMUM_ACCEPTED_PROFIT: BigDecimal = BigDecimal::from(0);
}

const CHECK_POSITIONS_INTERVAL: u64 = 10;
const MAX_RETRIES_VERIFY_TX_FINALITY: usize = 10;
const INTERVAL_CHECK_TX_FINALITY: u64 = 3;

pub struct MonitoringService {
    pub rpc_client: Arc<JsonRpcClient<HttpTransport>>,
    pub account: StarknetAccount,
    pub pragma_oracle: Arc<PragmaOracle>,
    pub positions_receiver: Receiver<Position>,
    pub positions: PositionsMap,
}

impl MonitoringService {
    pub fn new(
        rpc_client: Arc<JsonRpcClient<HttpTransport>>,
        account: StarknetAccount,
        pragma_api_base_url: String,
        pragma_api_key: String,
        positions_receiver: Receiver<Position>,
    ) -> MonitoringService {
        MonitoringService {
            rpc_client,
            account,
            pragma_oracle: Arc::new(PragmaOracle::new(pragma_api_base_url, pragma_api_key)),
            positions_receiver,
            positions: PositionsMap::new(),
        }
    }

    /// Starts the monitoring service.
    pub async fn start(mut self) -> Result<()> {
        let mut update_interval = interval(Duration::from_secs(CHECK_POSITIONS_INTERVAL));

        loop {
            tokio::select! {
                // Monitor the positions every N seconds
                _ = update_interval.tick() => {
                    self.monitor_positions_liquidability().await?;
                }

                // Insert the new positions indexed by the IndexerService
                maybe_position = self.positions_receiver.recv() => {
                    match maybe_position {
                        Some(position) => {
                            if !position.is_closed() {
                                self.positions.insert(position).await;
                            }
                        }
                        None => {
                            return Err(anyhow!("â›” Monitoring stopped unexpectedly."));
                        }
                    }
                }
            }
        }
    }

    /// Update all monitored positions and check if it's worth to liquidate any.
    /// TODO: Check issue for multicall update:
    /// https://github.com/astraly-labs/vesu-liquidator/issues/12
    /// TODO: Check all positions in parallel
    async fn monitor_positions_liquidability(&self) -> Result<()> {
        let monitored_positions = self.positions.0.read().await;
        if monitored_positions.is_empty() {
            return Ok(());
        }
        println!("\nðŸ”Ž Checking if any position is liquidable...");
        for (_, position) in monitored_positions.iter() {
            self.try_to_liquidate_position(position).await?;
        }
        println!("ðŸ¤¨ They're good.. for now...");
        Ok(())
    }

    /// Check if a position is liquidable, computes the profitability and if it's worth it
    /// liquidate it.
    async fn try_to_liquidate_position(&self, position: &Position) -> Result<BigDecimal> {
        if !position.is_liquidable(&self.pragma_oracle).await {
            return Ok(BigDecimal::from(0));
        }
        let (profit, txs) = self.compute_profitability(position).await?;
        if profit > *MINIMUM_ACCEPTED_PROFIT {
            let tx_hash_felt = self.account.execute_txs(&txs).await?;
            let tx_hash = tx_hash_felt.to_string();
            self.wait_for_tx_to_be_accepted(&tx_hash).await?;
            println!(
                "âœ… Liquidated position #{}! (TX #{})",
                position.key(),
                tx_hash
            );
        }
        Ok(profit)
    }

    /// Simulates the profit generated by liquidating a given position. Returns the profit
    /// and the transactions needed to liquidate the position.
    async fn compute_profitability(&self, position: &Position) -> Result<(BigDecimal, Vec<Call>)> {
        let liquidable_amount = position.liquidable_amount(&self.pragma_oracle).await?;

        let liquidation_txs = position.get_liquidation_txs(liquidable_amount.clone());
        let execution_fees = self.account.estimate_fees_cost(&liquidation_txs).await?;

        Ok((liquidable_amount - execution_fees, liquidation_txs))
    }

    /// Waits for a TX to be accepted on-chain.
    pub async fn wait_for_tx_to_be_accepted(&self, tx_hash: &str) -> Result<()> {
        let mut retries = 0;
        let duration_to_wait_between_polling = Duration::from_secs(INTERVAL_CHECK_TX_FINALITY);
        tokio::time::sleep(duration_to_wait_between_polling).await;

        let tx_hash = Felt::from_hex(tx_hash)?;
        loop {
            let response = self.rpc_client.get_transaction_receipt(tx_hash).await?;
            let status = response.receipt.finality_status();
            if *status != TransactionFinalityStatus::AcceptedOnL2 {
                retries += 1;
                if retries > MAX_RETRIES_VERIFY_TX_FINALITY {
                    return Err(anyhow!(
                        "Max retries exceeeded while waiting for tx {tx_hash} finality."
                    ));
                }
                tokio::time::sleep(duration_to_wait_between_polling).await;
            } else {
                break;
            }
        }
        Ok(())
    }
}
